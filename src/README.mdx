# Anotações sobre as aulas.

## Imports.

Exemplo de import individual.

```go
import "fmt"
```

Exemplo de múltiplos imports

```go
import (
	"fmt"
	"reflect"
)
```

## Variáveis.

As três formas de declaração que foram mostradas na aula são:

### Declaração com var.

Essa declaração é o equivalente ao "let" do JavaScript, é utilizada para valores que são atulizados após a declaração.

```go
package main

import "fmt"

func main() {
	var nome = "Paulo"
    nome = "Henrique"

    fmt.Println(nome); // Irá exibir "Henrique".
}
```

### Declaração com const.

Essa declaração é o equivalente ao "const" do JavaScript, é utilizada para valores constantes, que não irão sofrer uma nova atribuição após a declaração.

```go
package main

import "fmt"

func main() {
	const nome = "Paulo"
    nome = "Henrique" // Irá gerar um erro nessa linha, dizendo que o valor não pode ser atualizado.

    fmt.Println(nome); // Caso o programa continuasse após o erro, iria exibir "Paulo".
}
```

### Declaração curta.

Essa declaração é um atalho para a declaração com var, segue o mesmo funcionamento da mesma.

```go
package main

import "fmt"

func main() {
	nome := "Paulo"
    nome = "Henrique"

    fmt.Println(nome); // Irá exibir "Henrique".
}
```

## Tipos.

Você pode declarar os tipos junto da criação da variável, porém a linguagem Go cuida de fazer a inferência dos tipos automaticamente.

```go
package main

import "fmt"

func main() {
    var nome string = "Paulo"
    const idade int = 20

    // Existem dois tipos de float, float32 e float64, o que muda é o tamanho do espaço guardado pra variável.
    const peso float32 = 65.5

    sobrenome = "Souza" // No caso da declaração curta não é possível declarar o tipo.
}
```

## Pacotes.

### "fmt".

Esse pacote é o responsável pelas saídas e entradas do terminal.

```go
package main

import "fmt"

func main() {
    const nome = "Paulo"

	fmt.Println(nome) // Irá imprimir no termial o texto "Paulo", funciona similiar ao "println" de Java.

	var entrada int

    // É precisa definir qual caractere será digitado e definir uma variável para armazenar o valor da entrada.
	fmt.Scanf("%d", &entrada) // O "&" é obrigatório, ele é quem define que a variável que você tá passando vai ser atualizada.

    // É uma versão simplificada do comando anterior, não é preciso definir qual caractere será digitado.
	fmt.Scan(&entrada) // O "&" é obrigatório, ele é quem define que a variável que você tá passando vai ser atualizada.
}
```

### "reflect".

...

```go
package main

import "reflect"

func main() {
    const tipoDesconhecido = "Tipo"

    // Método "TypeOf" equivale ao "typeof" do JavaScript.
	fmt.Println(reflect.TypeOf(tipoDesconhecido)) // Irá exibir no terminal o texto "string"
}
```

### "os".

Pacote responsável por utilitários do sistema operacional.

```go
package main

import "os"

func main() {
    os.Exit(0) // Encerra o programa com sucesso.
    os.Exit(-1) // Encerra o programa com erro.
}
```

### "net/http".

Pacote responsável por fazer requisições externas.

```go
package main

import "net/http"

func main() {
	const requestUrl string = "www.google.com"

	resp, error := http.Get(requestUrl) // Busca alguma informação.
}
```


## Estruturas condicionais.

### "if".

Semelhante a outras linguagens com tipagem forte, diferente de JavaScript a condição tem sempre que ser uma expressão ou boolean.

```go
package main

import "fmt"

func main() {
    const texto string = "Paulo"
    const verdade bool = true

	if texto == "Paulo" { // Essa expressão retornaria true.
		fmt.Println("Expressão verdadeira.")
	} else if texto { // Retornaria um erro dizendo que o valor de "texto" não é válido, por ser uma string.
		fmt.Println("Expressão verdadeira.")
	} else if verdade { // Seria considerada válida.
		fmt.Println("Expressão verdadeira.")
	} else {
		fmt.Println("Expressão falsa.")
	}
}
```

### "switch".

Semelhante ao switch em outras linguagens, com diferença que não é precisio adicionar um "break" dentro dos cases.

```go
package main

import "fmt"

func main() {
    const nome string = "Paulo"

	switch comando {
	case "Paulo":
		fmt.Println("Olá, Paulo.")
	case "Henrique":
		fmt.Println("Olá, Henrique.")
	case "Silva":
		fmt.Println("Olá, Silva.")
	default:
		fmt.Println("Olá, desconhecido.")
	}
}
```

## Estruturas condicionais.

### "while".

A linguagem Go não tem a estrutura de repetições "while".

### "for"

Ao utilizar o "for" sem definir alguma condição para monitorar quando o looping deve parar, ele irá ser executado infinitamente, até que alguma ação interrompe ele, como por exemplo o método "Exit" do pacote "os".

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	for {
		fmt.Println("Rodou o Looping")

		os.Exit(0) // Se não houvesse essa linha, o looping iria imprimir "Rodou o Looping" infinitimanete no terminal.
	}
}
```


## Funções.

A declaração é feito com a palabra chave "func", caso queira criar uma função que retorne algo é preciso declarar o tipo do retorno primeiro.

```go
package main

import "fmt"

func olaMundo() {
    fmt.Println("Olá, Mundo.")
}

func retornaDois() int {
    return 2
}

func main() {
    olaMundo() // Irá exibir no console o texto "Olá, Mundo."

    numero := retornaDois() // O retorno da função será 2, como definimos a tipagem no retorna da função, podemos usar a declaração curta.
}
```

Algumas funções podem retornar mais de um valor, mas para isso você precisa passar a tipagem de retorno em parênteses e separados por vírgula.

```go
package main

func retornaDoisEQuatro() (int, int) {
    return 2, 4
}

func main() {
    numeroDois, numeroQuatro := retornaDoisEQuatro()
    _, numeroQuatro := retornaDoisEQuatro() // Caso você não queira usar um dos valores, você pode assinar a variável com _
}
```